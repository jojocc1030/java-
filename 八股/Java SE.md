### 1.  常见集合
Java集合类主要由两个根接口**Collection**和**Map**派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成**List、Set、Queue、Map**四种接口体系。

**注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口**。

Java集合框架图如下：

![](http://blog-img.coolsen.cn/img/image-20210403163733569.png)

![](http://blog-img.coolsen.cn/img/image-20210403163751501.png)

图中，
- **List代表了有序可重复集合**，**可直接根据元素的索引来访问；
- **Set**代表无序不可重复集合，只能根据元素本身来访问；
- **Queue**是队列集合。****

**Map代表的是存储key-value对的集合**，可根据元素的key来访问value。

上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。

### 2. 线程安全和线程不安全

**线程安全的：**

- **Hashtable：比HashMap多了个线程安全。**
- ConcurrentHashMap:是一种高效但是线程安全的集合。
- Vector：比Arraylist多了个同步化机制。
- Stack：栈，也是线程安全的，继承于Vector。

线性不安全的：

- HashMap
- Arraylist
- LinkedList
- HashSet
- TreeSet
- TreeMap

### 3. Arraylist 和 LinkedList 区别
- 相同点：
	- **线程不安全：** ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
- 不同点：
	- **底层数据结构：** 
		- **Arraylist** 底层使用的是**Object数组**；
		- **LinkedList** 底层使用的是**双向循环链表数据结构**；
	- **插入和删除是否受元素位置的影响：** **ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行`add(E e)`方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 **LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。**
	- **是否支持快速随机访问：** LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandomAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
	- **内存空间占用：** ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。
### 4. ArrayList 和 Vector区别
- **Vector是线程安全的，ArrayList不是线程安全的。** 其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。
- **ArrayList**在底层数组不够用时在原来的基础上**扩展0.5倍**，**Vector是扩展1倍**，这样ArrayList就有利于节约内存空间。
### 5. 深拷贝和浅拷贝
在 Java 中，深拷贝和浅拷贝的概念与 Python 稍有不同，因为 Java 中的对象赋值通常是基于引用的。但是，你可以使用不同的方式来实现深拷贝和浅拷贝。

1. **浅拷贝（Shallow Copy）**： 在 Java 中，浅拷贝通常是通过复制对象的引用来实现的，这意味着新对象和原始对象共享相同的子对象。可以使用以下方式来进行浅拷贝：
    
    - 对于数组，可以使用 `Arrays.copyOf()` 方法或者数组的 `clone()` 方法来创建一个新的数组，但是这只是对数组本身进行拷贝，而不是对数组中的元素进行拷贝。
    - 对于对象，可以实现 `Cloneable` 接口，并重写 `clone()` 方法来实现浅拷贝。默认情况下，`clone()` 方法会复制对象的字段，但是对于引用类型的字段，只是复制了引用，而不是对象本身。
2. **深拷贝（Deep Copy）**： 在 Java 中实现深拷贝比较复杂，因为默认情况下，对象的复制通常是基于引用的。为了实现深拷贝，你需要递归地复制对象的所有字段，包括引用类型的字段。可以使用以下方式来实现深拷贝：
    
    - 遍历对象的所有字段，对于每个字段，如果是基本类型，则直接复制其值；如果是引用类型，则递归地对其进行深拷贝。
    - 对于实现了 `Serializable` 接口的对象，可以使用**对象的序列化和反序列化**来实现深拷贝。将对象写入字节流，然后从字节流中读取，即可获得对象的深拷贝。

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于**引用拷贝**的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
![[shallow&deep-copy.png]]

### 6. ArrayList扩容
ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。**默认情况下，新的容量会是原容量的1.5倍**。

### 7. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？

- Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型，但是可以使用对应的包装类来存储基本类型的值。    
- Array 大小是固定的，ArrayList 的大小是动态变化的。
- ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。
总的来说，如果你需要一个固定大小的数据结构，并且已经知道数据的大小，那么可以使用 Array。而如果需要一个动态大小的数据结构，或者需要进行频繁的添加和删除操作，那么应该使用 ArrayList。
### 8. HashMap的底层数据结构是什么？
在JDK1.7 和JDK1.8 中有所差别：

在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。

在JDK1.8 中，由“**数组+链表+红黑树**”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：

- 当链表超过 8 且数据总量（数组长度）超过 64 才会转红黑树。
    
- 将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。
    

![Jdk1.8 HashMap结构](http://blog-img.coolsen.cn/img/image-20210112185830788.png)

### 9.   [解决hash冲突的办法有哪些？HashMap用的哪种？](https://www.javalearn.cn/#/doc/Java%E9%9B%86%E5%90%88/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_8-%e8%a7%a3%e5%86%b3hash%e5%86%b2%e7%aa%81%e7%9a%84%e5%8a%9e%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b%ef%bc%9fhashmap%e7%94%a8%e7%9a%84%e5%93%aa%e7%a7%8d%ef%bc%9f)

解决Hash冲突方法有:**开放定址法(再散列法)、再哈希法、链地址法（拉链法）、建立公共溢出区**。HashMap中采用的是**链地址法** 。

- 开放定址法也称为`再散列法`，基本思想就是，如果`p=H(key)`出现冲突时，则以`p`为基础，再次hash，`p1=H(p)`,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址`pi`。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以`只能在删除的节点上做标记，而不能真正删除节点。`
- 再哈希法(双重散列，多重散列)，提供多个不同的hash函数，当`R1=H1(key1)`发生冲突时，再计算`R2=H2(key1)`，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。
- **链地址法(拉链法)，** 将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。**链表法适用于经常进行插入和删除的情况。**
- 建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

### 10. [HashMap默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？](https://www.javalearn.cn/#/doc/Java%E9%9B%86%E5%90%88/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_10-hashmap%e9%bb%98%e8%ae%a4%e5%8a%a0%e8%bd%bd%e5%9b%a0%e5%ad%90%e6%98%af%e5%a4%9a%e5%b0%91%ef%bc%9f%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af-075%ef%bc%8c%e4%b8%8d%e6%98%af-06-%e6%88%96%e8%80%85-08-%ef%bc%9f)

回答这个问题前，我们来先看下HashMap的默认构造函数：

```java
     int threshold;             // 容纳键值对的最大值
     final float loadFactor;    // 负载因子
     int modCount;  
     int size;  
```

Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。**threshold = length * Load factor**。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。

默认的loadFactor是0.75，**0.75是对空间和时间效率的一个平衡选择**，一般不要修改，除非在时间和空间比较特殊的情况下 ：

- 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。

- 相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。



### [对象的相等和引用相等的区别](https://javaguide.cn/java/basis/java-basic-questions-02.html#对象的相等和引用相等的区别)

- 对象相等一般比较的是**内存中存放的内容**是否相等。
- 引用相等一般比较的是他们**指向的内存地址**是否相等。

### [深拷贝和浅拷贝区别了解吗？什么是引用拷贝？](#深拷贝和浅拷贝区别了解吗-什么是引用拷贝)

关于深拷贝和浅拷贝区别，我这里先给结论：

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

### [HashCode() 和 equals()的关系](https://www.cnblogs.com/skywang12345/p/3324958.html)


### [String、StringBuffer、StringBuilder 的区别？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string、stringbuffer、stringbuilder-的区别)

String不可变
StringBuffer 线程安全的
StringBuilder 线程不安全的

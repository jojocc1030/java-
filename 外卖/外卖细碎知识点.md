
## 阿里云oss云服务器

## 序列化器
- **序列化（Serialization）**：指将数据结构或对象转换成可传输或存储的形式，通常是字节流或字符串。序列化的过程中，数据被转换成一种格式，以便在网络上传输或存储到文件或数据库中。序列化后的数据可以是各种格式，比如JSON、XML、二进制格式等。序列化的目的是为了能够在不同的系统之间进行数据交换或持久化存储，并且保留数据的结构和语义。
    
- **反序列化（Deserialization）**：是序列化的逆过程，即将序列化后的数据重新转换成原始的数据结构或对象。反序列化的过程需要根据序列化时使用的格式和规则来重新构建数据结构，以便后续的处理和使用。反序列化通常是从网络接收数据或从文件或数据库读取数据时使用的操作。
## @Restcontroller
`@RestController` 是一个 Spring 框架中的注解，用于标识一个类是 RESTful 风格的控制器。在 Spring MVC 中，使用 `@RestController` 注解的类会自动将其返回的对象转换为 JSON 或 XML 格式，并通过 HTTP 响应发送给客户端。

具体来说，`@RestController` 注解相当于 `@Controller` 和 `@ResponseBody` 注解的结合。它是 Spring 4.0 版本引入的新特性，用于简化 RESTful Web 服务的开发。

## HttpClient
在Java中通过编码方式发送

1. **HttpClient的核心API：**

- HttpClient：Http客户端对象类型，使用该类型对象可发起Http请求。
- HttpClients：可认为是构建器，可创建`HttpClient`对象。
- CloseableHttpClient：实现类，实现了HttpClient接口。
- HttpGet：Get方式请求类型。
- HttpPost：Post方式请求类型。
- 
1. **HttpClient发送请求步骤：**

- 创建`HttpClient`对象
- 创建`Http`请求对象
- 调用`HttpClient`的execute方法发送请求
以下为示例：
GET
```java
        //创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        //创建请求对象
        HttpGet httpGet = new HttpGet("http://localhost:8080/user/shop/status");

        //发送请求，接受响应结果
        CloseableHttpResponse response = httpClient.execute(httpGet);
        
         //获取服务端返回的状态码
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println("服务端返回的状态码为：" + statusCode);
		
		//获取服务端返回数据
        HttpEntity entity = response.getEntity();
        String body = EntityUtils.toString(entity);
        System.out.println("服务端返回的数据为：" + body);

        //关闭资源
        response.close();
        httpClient.close();

```

  POST
  ```java
	/**
     * 测试通过httpclient发送POST方式的请求
     */
    @Test
    public void testPOST() throws Exception{
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        //创建请求对象
        HttpPost httpPost = new HttpPost("http://localhost:8080/admin/employee/login");

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("username","admin");
        jsonObject.put("password","123456");

        StringEntity entity = new StringEntity(jsonObject.toString());
        //指定请求编码方式
        entity.setContentEncoding("utf-8");
        //数据格式
        entity.setContentType("application/json");
        httpPost.setEntity(entity);

        //发送请求
        CloseableHttpResponse response = httpClient.execute(httpPost);

        //解析返回结果
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println("响应码为：" + statusCode);

        HttpEntity entity1 = response.getEntity();
        String body = EntityUtils.toString(entity1);
        System.out.println("响应数据为：" + body);

        //关闭资源
        response.close();
        httpClient.close();
    }
```
  	


## 微信小程序
1. 微信登陆
	![[Pasted image 20240319143346.png]]
**步骤分析：**

1. 小程序端，调用wx.login()获取code，就是授权码。
2. 小程序端，调用wx.request()发送请求并携带code，请求开发者服务器(自己编写的后端服务)。
3. **开发者服务端**，通过HttpClient向微信接口服务发送请求，并携带appId+appsecret+`code`三个参数。**（[code2session](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html)）**(其中最重要的是code, 这是从前端发过来的)
5. **开发者服务端**，接收微信接口服务返回的数据，session_key+opendId等。**openId**是微信用户的唯一标识。（(其中最重要的是openId, 这是返回给前端的)）
6. **开发者服务端**，自定义登录态，生成令牌(token)和openid等数据返回给小程序端，方便后绪请求身份校验。
7. 小程序端，收到自定义登录态，存储storage。
8. 小程序端，后绪通过wx.request()发起业务请求时，携带token。
9. 开发者服务端，收到请求后，通过携带的token，解析当前登录用户的id。
10. 开发者服务端，身份校验通过后，继续相关的业务逻辑处理，最终返回业务数据。
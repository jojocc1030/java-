- 使用HttpClient完成微信小程序的用户的登录，接受前端返回的code，使用httpClient封装请求，调用微信服务接口，获得openId等属性后再返回给前端
	1. **开发者服务端**，通过HttpClient向微信接口服务发送请求，并携带appId+appsecret+`code`三个参数。**（[code2session](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html)）**(其中最重要的是code, 这是从前端发过来的)
	2. **开发者服务端**，接收微信接口服务返回的数据，session_key+opendId等。**openId**是微信用户的唯一标识。(其中最重要的是openId, 这是返回给前端的)
	3. **开发者服务端**，自定义登录态，生成令牌(token)和openid等数据返回给小程序端，方便后绪请求身份校验。
- [ ] aop
- [ ] 阿里云oss
- [ ] nginx反向代理
- [ ] swagger api注解
- [ ] redis
- [ ] pageHelper  分页
- [ ] ThreadLocal 存放userId,
- [x] springtask 处理：
	- 下单后未支付，订单一直处于“**待支付**”状态
	- 用户收货后管理端未点击完成按钮，订单一直处于“**派送中**”状态
- [x] websocket :
	- 用户下单成功后，通知外卖商家
	- 用户催单时，通知外卖商家
- [ ] **redission**实现分布式锁，以实现优惠券秒杀功能：[https://blog.csdn.net/m0_71777195/article/details/126419861](https://blog.csdn.net/m0_71777195/article/details/126419861)
	[视频讲解redission实现分布式锁](https://www.bilibili.com/video/BV1pR4y1x7Gy/?spm_id_from=333.337.search-card.all.click&vd_source=873bbae1ebcad1f80f75aa650df5d259)
	
## 布隆过滤器 #布隆过滤器
	![[Pasted image 20240325115526.png]]
	- 底层数据结构是bitmap，使用bit存储判断海量数据是否存在。
	- 哈希碰撞：使用多种哈希算法解决哈希碰撞问题。只是减小误判几率，不能做到绝对不误判。**不存在一定不存在，存在不一定存在。**
	- 解决误判问题：1.增加位数长度；2.增加hash个数
		![[Pasted image 20240325120245.png]]
	- 开发实现：
		使用redisson组件进行开发：参数值{预计的插入数量，可接受的容错率}![[Pasted image 20240325120501.png]]
		`bloomFilter.tryInit(1000000L, 0.01);` 这行代码中的两个参数分别表示布隆过滤器的初始化容量和误判率。具体解释如下：
		
### 缓存穿透问题

缓存穿透是指用户请求的数据在缓存和数据库中都不存在，每次请求都会穿透缓存直接查询数据库，导致缓存失效，数据库压力增大。

### 布隆过滤器

布隆过滤器是一种空间效率高的概率型数据结构，用于判断一个元素是否在一个集合中。它能够有效地减少缓存穿透问题。布隆过滤器由一个位数组和一组哈希函数组成，通过哈希函数计算数据的指定位来判断数据是否存在于集合中。
### 底层原理

布隆过滤器通过多个哈希函数将数据映射到位数组中，当需要检查某个数据是否存在时，使用相同的哈希函数计算指定位，如果所有指定位都为1，则认为数据存在。由于布隆过滤器是概率型数据结构，存在一定的误判率，但不会出现漏判。因此，它适用于缓存穿透问题的场景。
### 参数解释

1. **容量（1000000L）**：
    
    - **意义**：布隆过滤器预期要存储的元素数量。在这个例子中，设置为1000000，表示预计要存储100万个元素。
    - **设置依据**：根据实际业务需求估算需要存储的最大元素数量。一般情况下，这个值应该略大于实际的最大数据量，以防止过多误判。
2. **误判率（0.01）**：
    
    - **意义**：布隆过滤器的误判率，表示查询一个不存在的元素时，布隆过滤器误判为存在的概率。在这个例子中，设置为0.01，表示1%的误判率。
    - **设置依据**：根据业务对误判率的容忍度来设置。误判率越低，需要的位数组大小和哈希函数数量就越多，空间和时间开销越大。

### 设置依据

- **容量**： 设定容量时，可以根据系统实际的数据量来设置。比如，如果系统中预计会有10万个菜品ID，为了有一定的余量，可以设置为10万到20万之间。
    
- **误判率**： 设置误判率时，需要在空间消耗和误判率之间做权衡。较低的误判率意味着需要更多的内存来存储位数组，同时需要更多的哈希函数进行计算。
    

### 示例设置

假设系统中预计有10万个菜品ID，容忍1%的误判率，初始化布隆过滤器可以设置如下：

java

`bloomFilter.tryInit(100000L, 0.01);`

### 计算位数组大小和哈希函数数量

布隆过滤器的位数组大小`m`和哈希函数数量`k`可以根据以下公式计算：

- 位数组大小`m = - (n * ln(p)) / (ln(2)^2)`，其中`n`是预计的元素数量，`p`是误判率。
- 哈希函数数量`k = (m / n) * ln(2)`。

以`n=100000`和`p=0.01`为例：

- `m ≈ - (100000 * ln(0.01)) / (ln(2)^2) ≈ 958506`
- `k ≈ (958506 / 100000) * ln(2) ≈ 6.64`，取整为7。




校园派
使用到的技术:Springboot+SpringMVC+mybatis+redis+jwt

项目功能:一款校园内的学校食堂外卖服务。学生使用小程序进行点餐，食堂负责接单并制作菜品派送到指定宿舍楼。实现员工、菜品管理功能，包括后台管理系统与客户端双系统。实现订单、购物车，来单提醒、优惠券秒杀等功能。
项目亮点:
使用Redis缓存数据，将查询时间由平均127ms优化至23ms
通过**延迟删除+主动更新方案**解决数据一致性问题
- [x] 使用redisson组件实现布隆过滤器解决缓存穿透问题  #布隆过滤器 
实现优惠卷功能，并通过乐观锁解决超卖问题  **（为什么用乐观锁实现而非悲观锁实现，为什么不用sychronized互斥锁）**
使用Redis分布式锁来解决优惠券超卖问题
使用JWT令牌技术，用定义拦截器完成用户认证，通过ThreadLocal优化鉴权逻辑
使用Nginx作为http服务器，部署反向代理和负载均衡

通过WebSocket向前端传输数据，实现来单提醒功能，**（实现用户和后台进行对话的功能？？？）**
使用SpringTask进行定时任务调度，定期处理支付超时订单。






![[Pasted image 20240322193443.png]]



### 限时优惠菜品秒杀
https://maimai.cn/article/detail?fid=1770679400&efid=dDE1lWUraiNHFWaJxwyIfg
#### 库存判断：
![[Pasted image 20240404152436.png]]
乐观锁解决超卖问题：
先判断库存是否大于0，当前大于0就继续执行后续逻辑，在扣减库存时，使用mysql的where条件语句判断库存是否大于0，若大于0则执行扣减库存操作成功：
下面给出 CAS 法扣除库存时，针对超卖问题的解决方案：(MyBatisPlus)

// 扣减库存
  ```java
 boolean success = seckillVoucherService.update()
                    .setSql("stock = stock - 1") // set stock = stock - 1
                    .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                    .update();
```

#### 一人一单：
判断库存充足后，再去确认当前用户是否已经下过单（去订单表里查询），如果没有下过单，再扣减库存
![[Pasted image 20240404154710.png]]

存在问题：因为上述的实现是分成两步的：

1. 判断当前用户在数据库中并没有订单
    
2. 执行扣除库存操作，并生成订单

也正因为是分成了两步，所以才引发了**线程安全问题**： 可以是同一个用户的多个请求线程都同时判断没有订单，后续则大家都执行了扣除操作。

要解决这个问题，也很简单，只要让这两步串行执行即可，也就是加锁！保证**原子性**


**使用用户id作为锁对象，下调锁粒度，一定程度上提高了性能**

#### 一人一单的并发安全问题：

> 因为 synchronized 锁的是对应 JVM 内的锁监视器，可是不同的结点有不同的 JVM，不同的 JVM 又有不同的锁监视器，所以刚刚的设计在集群模式下锁住的其实还是不同的对象，即无法解决线程安全问题。

过期时间 + 在获取锁之后，将value设为唯一锁标识（UUID + threadID）


- 原子性问题

刚刚我们谈论的释放锁的逻辑：

1. 判断当前锁是当前线程的锁
    
2. 当前线程释放锁
要实现这两步是**原子操作**

**引入 Lua 脚本保持原子性**

lua 脚本：

```lua
-- 比较线程标示与锁中的标示是否一致
if(redis.call('get', KEYS[1]) ==  ARGV[1]) then
    -- 释放锁 del key
    return redis.call('del', KEYS[1])
end
return 0
```


还存在的问题：
- **超时释放**：依然存在锁续命的问题
- **不可重入**：
- **不可重试**
- **主从一致性问题**


**总结**

**这一次我们从秒杀场景的业务需求出发，一步步地利用 Redis 设计出一种生产可用的分布式锁：**

**实现思路：**

1. **利用set nx ex获取锁，并设置过期时间，保存线程标示**
    
2. **释放锁时先判断线程标示是否与自己一致，一致则删除锁 (Lua 脚本保证原子性)**
    

  

**有哪些特性？**

1. **利用set nx满足互斥性**
    
2. **利用set ex保证故障时锁依然能释放，避免死锁，提高安全性**
    
3. **利用Redis集群保证高可用和高并发特性**
    

  

**目前还有待完善的点：**

1. **不可重入，同一个线程无法多次获取同一把锁**
    
2. **不可重试，获取锁只尝试一次就返回false，没有重试机制**
    
3. **超时释放，锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患（虽然已经解决了误删问题，但是仍然可能存在未知问题）**
    
4. **主从一致性，如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，在主节点中的锁数据并没有及时同步到从节点中，则会导致其他线程也能获得锁，引发线程安全问题（延迟时间是在毫秒以下的，所以这种情况概率极低）**

#### Redisson

1. 可重入： 使用redis的哈希结构，field记录线程唯一标识，value重入次数
	![[Pasted image 20240404171635.png]]
2. 可重试 ，设置waitTime， 在waitTime未超时的时间内，会尝试获取锁
3. 锁超时：（WatchDog原理）
	默认锁超时时间是30s，每1/3 锁超时时间时，watchDog进行锁续命，重置锁的有效期，直到锁释放为止。
	**注意：如果自己设置leasetime(默认值为-1)，则不会走看门狗逻辑。**
	 ![[Pasted image 20240404174307.png]]
	

![[Pasted image 20240514123148.png]]
![[Pasted image 20240514123534.png]]
黑马待学内容：
- [x] 分布式锁
- [ ] 共享session登录问题
- [x] 点赞排行榜

